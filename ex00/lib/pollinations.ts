import axios from 'axios';
import { PokemonFormData } from '../app/types/pokemon';

const POLLINATIONS_API_URL = 'https://image.pollinations.ai/prompt/';

export async function generatePokemonImage(data: PokemonFormData): Promise<string> {
  const prompt = generatePrompt(data);
  const encodedPrompt = encodeURIComponent(prompt);

  // Usar parámetros más específicos para mejorar la calidad
  const params = new URLSearchParams({
    width: '512',
    height: '512',
    quality: 'high',
    seed: Math.floor(Math.random() * 1000000).toString(),
    model: 'sdxl', // Usar SDXL para mejor calidad
    guidance: '7.5', // Aumentar la guía para mejor adherencia al prompt
    steps: '30' // Más pasos para mejor calidad
  });

  const imageUrl = `${POLLINATIONS_API_URL}${encodedPrompt}?${params.toString()}`;

  console.log('Generated URL:', imageUrl);

  // Verify the image is generated by making a HEAD request
  try {
    await axios.head(imageUrl);
    return imageUrl;
  } catch (error) {
    console.error('Error generating image:', error);
    // Intentar sin parámetros adicionales como fallback
    const fallbackUrl = `${POLLINATIONS_API_URL}${encodedPrompt}`;
    try {
      await axios.head(fallbackUrl);
      return fallbackUrl;
    } catch (fallbackError) {
      console.error('Fallback also failed:', fallbackError);
      throw new Error('Failed to generate Pokemon image');
    }
  }
}

// Función alternativa con prompt más simple
export async function generatePokemonImageSimple(data: PokemonFormData): Promise<string> {
  const prompt = generateSimplePrompt(data);
  const encodedPrompt = encodeURIComponent(prompt);

  // Usar solo el endpoint básico sin parámetros adicionales
  const imageUrl = `${POLLINATIONS_API_URL}${encodedPrompt}`;

  console.log('Simple generated URL:', imageUrl);

  try {
    // No hacer HEAD request, solo retornar la URL directamente
    return imageUrl;
  } catch (error) {
    console.error('Error generating simple image:', error);
    throw new Error('Failed to generate Pokemon image');
  }
}

// Función de prueba para verificar la API
export async function testPollinationsAPI(): Promise<string> {
  const testPrompt = 'a cute red cat, digital art';
  const encodedPrompt = encodeURIComponent(testPrompt);
  const imageUrl = `${POLLINATIONS_API_URL}${encodedPrompt}`;

  console.log('Test URL:', imageUrl);
  return imageUrl;
}

function generatePrompt(data: PokemonFormData): string {
  // Crear un prompt más estructurado y específico
  const basePrompt = `Pokemon character named ${data.name}`;

  const styleModifiers = {
    cute: 'adorable, kawaii style, soft pastel colors, big eyes, round features, friendly expression, chibi style',
    fierce: 'powerful, muscular build, dynamic pose, intense colors, sharp features, aggressive expression, battle-ready',
    mystical: 'ethereal, magical aura, glowing elements, mysterious, otherworldly, cosmic energy, enchanted',
    robotic: 'mechanical parts, metallic texture, sci-fi design, technological, cybernetic, artificial, futuristic',
    elemental: 'natural elements, organic design, flowing forms, nature-inspired, primal energy, elemental magic',
    ancient: 'ancient symbols, weathered appearance, mythological, legendary, time-worn, mystical, primordial'
  };

  const typeModifiers = {
    fire: 'flames, fire elements, warm colors, heat waves, burning aura, fiery design, fire type Pokemon',
    water: 'aquatic features, flowing design, bubbles, water elements, fluid movement, oceanic, water type Pokemon',
    electric: 'lightning patterns, sparks, energy bolts, electric blue, static energy, power surges, electric type Pokemon',
    grass: 'plant elements, leaves, natural growth, green tones, organic patterns, nature magic, grass type Pokemon',
    psychic: 'cosmic energy, psychedelic patterns, mental powers, purple aura, telekinetic effects, psychic type Pokemon',
    dragon: 'scales, majestic presence, mythical, powerful wings, ancient wisdom, legendary, dragon type Pokemon',
    ghost: 'ethereal, transparent parts, spooky, shadowy, spectral, otherworldly, ghost type Pokemon',
    fairy: 'sparkles, pastel colors, whimsical, magical, enchanting, delicate features, fairy type Pokemon',
    dark: 'shadows, dark aura, mysterious, sinister, shadow powers, night-themed, dark type Pokemon',
    steel: 'metallic surface, mechanical parts, industrial, tough, armored, technological, steel type Pokemon',
    ice: 'crystalline structure, frost patterns, frozen elements, cool colors, glacial, ice type Pokemon',
    ground: 'earthy textures, robust design, solid, grounded, natural strength, terraforming, ground type Pokemon',
    rock: 'mineral patterns, crystalline features, stone-like, geological, solid foundation, rock type Pokemon',
    fighting: 'muscular build, dynamic pose, combat-ready, warrior spirit, battle-hardened, fighting type Pokemon',
    poison: 'toxic colors, chemical elements, venomous, corrosive, dangerous, toxic aura, poison type Pokemon',
    bug: 'insect features, compound eyes, chitinous armor, natural camouflage, swarm-like, bug type Pokemon',
    flying: 'aerodynamic design, wings, wind elements, sky-bound, graceful, soaring, flying type Pokemon',
    normal: 'balanced design, natural features, adaptable, versatile, well-rounded, standard, normal type Pokemon'
  };

  const style = styleModifiers[data.style as keyof typeof styleModifiers] || '';
  const type = typeModifiers[data.type as keyof typeof typeModifiers] || '';

  // Construir un prompt más detallado y específico para Pokemon
  const detailedPrompt = `${basePrompt}, ${type}, ${style}, Pokemon game art style, character design, full body shot, centered composition, vibrant colors, professional illustration, high quality, detailed, digital art, game asset`;

  console.log('Generated prompt:', detailedPrompt);
  return detailedPrompt;
}

function generateSimplePrompt(data: PokemonFormData): string {
  // Prompt más simple y directo
  const styleMap = {
    cute: 'cute',
    fierce: 'fierce',
    mystical: 'mystical',
    robotic: 'robotic',
    elemental: 'elemental',
    ancient: 'ancient'
  };

  const style = styleMap[data.style as keyof typeof styleMap] || data.style;

  return `${data.name} ${data.type} type ${style} Pokemon, digital art`;
}